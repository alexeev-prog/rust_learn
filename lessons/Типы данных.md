 В Rust существует все популярные типы данных, с учетом того что Rust - в основном системный и низкоуровневый язык.

Типы данных бывают следующие:

## Числа

### Целые и десятичные числа

Для создания целых чисел и чисел с плавающей точкой в Rust применяется традиционный синтаксис. В операциях с числами применяется инфиксная нотация, означающая, что числовые выражения выглядят так, как многие привыкли их видеть в большинстве языков программирования. При работе с несколькими типами в Rust допускается применение для сложения одного и того же знака. Этот прием называется *перегрузкой операторов*.

1. В языке Rust имеется большое количество числовых типов. У вас выработается привычка объявлять размер в байтах, что окажет влияние на количество чисел, представляемых типом, и на то, сможет ли он предоставить отрицательные значения.
2. Преобразования между типами всегда носят явный характер. Rust не производит автоматическое преобразование 16-разрядного целого числа в 32-разрядное.
3. В Rust у чисел могут быть методы. Например для округления 24.5 к ближайшему числу Rust-программисты используют не традиционных подход (`round(24.5_f32)`), а вызов метода `24.5_f32.round()`. Здесь наличие суффикса типа объясняется необходимостью указания конкретного типа.

```rust
fn main() {
	let twenty = 20;
	let twenty_one: i32 = 21;
	let twenty_two = 22_i32;
	let addition = twenty + twenty_one + twenty_two;
	
	println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);
	
	let one_million: i64 = 1_000_000;
	println!("{}", one_million.pow(2));

	let forty_twos = [
		42.0,
		42f32,
		42.0_f32
	];

	println!("{:02}", forty_twos[0]);
}
```

### Записи чисел с основанием 2, 8 и 16
В Rust также имеется встроенная поддержка числовых литералов, позволяющих определять целые числа по основанию 2 (двоичные), по основанию 8 (восьмеричные) и по основанию 16 (шестнадцатеричные). Эта нотация также доступна при форматировании таких макросов, как `println!`.

```rust
fn main() {
	let three = 0b11;
	let thirty = 0o36;
	let three_hundred = 0x12C;
	
	println!("base 10: {} {} {}", three, thirty, three_hundred);
	println!("base 2: {:b} {:b} {:b}", three, thirty, three_hundred);
	println!("base 8: {:o} {:o} {:o}", three, thirty, three_hundred);
	println!("base 16: {:x} {:x} {:x}", three, thirty, three_hundred);
}
```

В двоичных (по основанию 2) записях чисел `0b11` равно 3, поскольку 3 = 2 * 1 + 1 * 1. В восьмеричных (по основанию 8) записях чисел `0o36` равно 30, поскольку 30 = 8 * 3 + 1 * 6. А в шестнадцатеричных (по основанию 16) записях чисел `0x12C` равно 300, поскольку 300 = 256 * 1 + 16 * 2 + 1 * 12. Типы, представляющие скалярные числа, показаны в таблицу ниже:

| Тип                   | Описание                                                                                                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| u8, u16, u32, u64     | Целые числа без знака в диапазоне от 8 до 64 разрядов                                                                                                                    |
| i8, i16, i32, i64<br> | Целые числа со знаком в диапазоне от 8 до 64 разрядов                                                                                                                    |
| f32, f64              | Числа с плавающей точкой в 32-разрядном и 64-разрядном вариантах                                                                                                         |
| isize, usize          | Целые числа, предполагающие "исходную" разрядность центрального процессора. Например, в 64-разрядных центральных процессорах `usize` и `isize` будут шириной 64-разряда. |
